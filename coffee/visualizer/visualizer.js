// Generated by CoffeeScript 1.9.1
(function() {
  'use strict';
  var $, Graphics, PI, Point, Rect, ToolHighlighter, ToolIntersectionBuilder, ToolIntersectionMover, ToolMover, ToolRoadBuilder, Visualizer, Zoomer, _, chroma, settings,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  PI = Math.PI;

  require('../helpers');

  $ = require('jquery');

  _ = require('underscore');

  chroma = require('chroma-js');

  Point = require('../geom/point');

  Rect = require('../geom/rect');

  Graphics = require('./graphics');

  ToolMover = require('./mover');

  ToolIntersectionMover = require('./intersection-mover');

  ToolIntersectionBuilder = require('./intersection-builder');

  ToolRoadBuilder = require('./road-builder');

  ToolHighlighter = require('./highlighter');

  Zoomer = require('./zoomer');

  settings = require('../settings');

  Visualizer = (function() {
    function Visualizer(world) {
      this.world = world;
      this.draw = bind(this.draw, this);
      this.$canvas = $('#canvas');
      this.canvas = this.$canvas[0];
      this.ctx = this.canvas.getContext('2d');
      this.carImage = new Image();
      this.carImage.src = 'images/car.png';
      this.updateCanvasSize();
      this.zoomer = new Zoomer(4, this, true);
      this.graphics = new Graphics(this.ctx);
      this.toolRoadbuilder = new ToolRoadBuilder(this, true);
      this.toolIntersectionBuilder = new ToolIntersectionBuilder(this, true);
      this.toolHighlighter = new ToolHighlighter(this, true);
      this.toolIntersectionMover = new ToolIntersectionMover(this, true);
      this.toolMover = new ToolMover(this, true);
      this._running = false;
      this.previousTime = 0;
      this.timeFactor = settings.defaultTimeFactor;
      this.debug = false;
    }

    Visualizer.prototype.drawIntersection = function(intersection, alpha) {
      var color;
      color = intersection.color || settings.colors.intersection;
      this.graphics.drawRect(intersection.rect);
      this.ctx.lineWidth = 0.4;
      this.graphics.stroke(settings.colors.roadMarking);
      return this.graphics.fillRect(intersection.rect, color, alpha);
    };

    Visualizer.prototype.drawSignals = function(road) {
      var intersection, lights, lightsColors, segment, sideId;
      lightsColors = [settings.colors.redLight, settings.colors.greenLight];
      intersection = road.target;
      segment = road.targetSide;
      sideId = road.targetSideId;
      lights = intersection.controlSignals.state[sideId];
      this.ctx.save();
      this.ctx.translate(segment.center.x, segment.center.y);
      this.ctx.rotate((sideId + 1) * PI / 2);
      this.ctx.scale(1 * segment.length, 1 * segment.length);
      if (lights[0]) {
        this.graphics.drawTriangle(new Point(0.1, -0.2), new Point(0.2, -0.4), new Point(0.3, -0.2));
        this.graphics.fill(settings.colors.greenLight);
      }
      if (lights[1]) {
        this.graphics.drawTriangle(new Point(0.3, -0.1), new Point(0.5, 0), new Point(0.3, 0.1));
        this.graphics.fill(settings.colors.greenLight);
      }
      if (lights[2]) {
        this.graphics.drawTriangle(new Point(0.1, 0.2), new Point(0.2, 0.4), new Point(0.3, 0.2));
        this.graphics.fill(settings.colors.greenLight);
      }
      return this.ctx.restore();
    };

    Visualizer.prototype.drawRoad = function(road, alpha) {
      var dashSize, k, lane, leftLine, len, line, ref, rightLine, sourceSide, targetSide;
      if ((road.source == null) || (road.target == null)) {
        throw Error('invalid road');
      }
      sourceSide = road.sourceSide;
      targetSide = road.targetSide;
      this.ctx.save();
      this.ctx.lineWidth = 0.4;
      leftLine = road.leftmostLane.leftBorder;
      this.graphics.drawSegment(leftLine);
      this.graphics.stroke(settings.colors.roadMarking);
      rightLine = road.rightmostLane.rightBorder;
      this.graphics.drawSegment(rightLine);
      this.graphics.stroke(settings.colors.roadMarking);
      this.ctx.restore();
      this.graphics.polyline(sourceSide.source, sourceSide.target, targetSide.source, targetSide.target);
      this.graphics.fill(settings.colors.road, alpha);
      this.ctx.save();
      ref = road.lanes.slice(1);
      for (k = 0, len = ref.length; k < len; k++) {
        lane = ref[k];
        line = lane.rightBorder;
        dashSize = 1;
        this.graphics.drawSegment(line);
        this.ctx.lineWidth = 0.2;
        this.ctx.lineDashOffset = 1.5 * dashSize;
        this.ctx.setLineDash([dashSize]);
        this.graphics.stroke(settings.colors.roadMarking);
      }
      return this.ctx.restore();
    };

    Visualizer.prototype.drawCar = function(car) {
      var angle, boundRect, center, curve, l, rect, ref, style;
      angle = car.direction;
      center = car.coords;
      rect = new Rect(0, 0, 1.1 * car.length, 1.7 * car.width);
      rect.center(new Point(0, 0));
      boundRect = new Rect(0, 0, car.length, car.width);
      boundRect.center(new Point(0, 0));
      this.graphics.save();
      this.ctx.translate(center.x, center.y);
      this.ctx.rotate(angle);
      l = 0.90 - 0.30 * car.speed / car.maxSpeed;
      style = chroma(car.color, 0.8, l, 'hsl').hex();
      this.graphics.fillRect(boundRect, style);
      this.graphics.restore();
      if (this.debug) {
        this.ctx.save();
        this.ctx.fillStyle = "black";
        this.ctx.font = "1px Arial";
        this.ctx.fillText(car.id, center.x, center.y);
        if ((curve = (ref = car.trajectory.temp) != null ? ref.lane : void 0) != null) {
          this.graphics.drawCurve(curve, 0.1, 'red');
        }
        return this.ctx.restore();
      }
    };

    Visualizer.prototype.drawGrid = function() {
      var box, gridSize, i, j, k, rect, ref, ref1, ref2, results, sz;
      gridSize = settings.gridSize;
      box = this.zoomer.getBoundingBox();
      if (box.area() >= 2000 * gridSize * gridSize) {
        return;
      }
      sz = 0.4;
      results = [];
      for (i = k = ref = box.left(), ref1 = box.right(), ref2 = gridSize; ref2 > 0 ? k <= ref1 : k >= ref1; i = k += ref2) {
        results.push((function() {
          var m, ref3, ref4, ref5, results1;
          results1 = [];
          for (j = m = ref3 = box.top(), ref4 = box.bottom(), ref5 = gridSize; ref5 > 0 ? m <= ref4 : m >= ref4; j = m += ref5) {
            rect = new Rect(i - sz / 2, j - sz / 2, sz, sz);
            results1.push(this.graphics.fillRect(rect, settings.colors.gridPoint));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Visualizer.prototype.updateCanvasSize = function() {
      if (this.$canvas.attr('width') !== $(window).width || this.$canvas.attr('height') !== $(window).height) {
        return this.$canvas.attr({
          width: $(window).width(),
          height: $(window).height()
        });
      }
    };

    Visualizer.prototype.draw = function(time) {
      var car, delta, id, intersection, ref, ref1, ref2, ref3, road;
      delta = (time - this.previousTime) || 0;
      if (delta > 30) {
        if (delta > 100) {
          delta = 100;
        }
        this.previousTime = time;
        this.world.onTick(this.timeFactor * delta / 1000);
        this.updateCanvasSize();
        this.graphics.clear(settings.colors.background);
        this.graphics.save();
        this.zoomer.transform();
        this.drawGrid();
        ref = this.world.intersections.all();
        for (id in ref) {
          intersection = ref[id];
          this.drawIntersection(intersection, 0.9);
        }
        ref1 = this.world.roads.all();
        for (id in ref1) {
          road = ref1[id];
          this.drawRoad(road, 0.9);
        }
        ref2 = this.world.roads.all();
        for (id in ref2) {
          road = ref2[id];
          this.drawSignals(road);
        }
        ref3 = this.world.cars.all();
        for (id in ref3) {
          car = ref3[id];
          this.drawCar(car);
        }
        this.toolIntersectionBuilder.draw();
        this.toolRoadbuilder.draw();
        this.toolHighlighter.draw();
        this.graphics.restore();
      }
      if (this.running) {
        return window.requestAnimationFrame(this.draw);
      }
    };

    Visualizer.property('running', {
      get: function() {
        return this._running;
      },
      set: function(running) {
        if (running) {
          return this.start();
        } else {
          return this.stop();
        }
      }
    });

    Visualizer.prototype.start = function() {
      if (!this._running) {
        this._running = true;
        return this.draw();
      }
    };

    Visualizer.prototype.stop = function() {
      return this._running = false;
    };

    return Visualizer;

  })();

  module.exports = Visualizer;

}).call(this);
